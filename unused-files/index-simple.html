<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game Prototyping Framework</title>
  <link rel="stylesheet" href="css/main.css">
  <link rel="stylesheet" href="css/components/hot-reload.css">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Poppins:wght@600;700&display=swap" rel="stylesheet">
  <style>
    /* Basic fallback styles if CSS files fail to load */
    body {
      font-family: 'Montserrat', sans-serif;
      background-color: #0d1117;
      color: #e6edf3;
      margin: 0;
      padding: 0;
    }
    
    .outer-container {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    
    .game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 1200px;
      margin: 0 auto;
      width: 100%;
      padding: 0 20px;
      box-sizing: border-box;
    }
    
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 0;
      border-bottom: 1px solid #30363d;
    }
    
    .game-title {
      margin: 0;
      color: #58a6ff;
      font-size: 1.5rem;
    }
    
    .game-content {
      display: grid;
      gap: 20px;
      padding: 20px 0;
      flex: 1;
    }
    
    .betting-zone {
      background-color: #161b22;
      border-radius: 8px;
      padding: 20px;
    }
    
    .playground-zone {
      background-color: #161b22;
      border-radius: 8px;
      position: relative;
      aspect-ratio: 16/9;
      overflow: hidden;
    }
    
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    .footer {
      display: flex;
      justify-content: space-between;
      padding: 15px 0;
      border-top: 1px solid #30363d;
      font-size: 14px;
      color: #8b949e;
    }
    
    /* Theme system */
    :root {
      --color-bg-primary: #0d1117;
      --color-bg-secondary: #161b22;
      --color-border: #30363d;
      --color-text: #e6edf3;
      --color-text-secondary: #8b949e;
      --color-accent: #58a6ff;
      --color-success: #2ea043;
      --color-warning: #d29922;
      --color-error: #f85149;
      --color-button: #238636;
      --color-button-hover: #2ea043;
    }
    
    /* Control elements */
    .btn {
      background-color: var(--color-button);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.2s;
    }
    
    .btn:hover {
      background-color: var(--color-button-hover);
    }
    
    .btn-outline {
      background-color: transparent;
      border: 1px solid var(--color-border);
      color: var(--color-text);
    }
    
    .select-dropdown {
      padding: 8px 12px;
      background-color: var(--color-bg-primary);
      color: var(--color-text);
      border: 1px solid var(--color-border);
      border-radius: 4px;
      width: 100%;
    }
    
    /* Betting controls */
    .control-panel-title {
      display: block;
      margin-bottom: 10px;
      color: var(--color-text-secondary);
      font-weight: bold;
    }
    
    .bet-input-group {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      gap: 10px;
    }
    
    .bet-input {
      flex: 1;
      text-align: center;
      padding: 8px;
      background-color: var(--color-bg-primary);
      color: var(--color-text);
      border: 1px solid var(--color-border);
      border-radius: 4px;
    }
    
    .quick-bets {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .quick-bet {
      flex: 1;
      background-color: var(--color-bg-primary);
      color: var(--color-text);
      border: 1px solid var(--color-border);
      padding: 5px;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .spin-btn {
      background-color: var(--color-button);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      width: 100%;
      transition: background-color 0.2s;
    }
    
    .spin-btn:hover {
      background-color: var(--color-button-hover);
    }
    
    /* Risk level control */
    .risk-panel {
      margin-bottom: 20px;
    }
    
    .risk-panel-title {
      display: block;
      margin-bottom: 10px;
      color: var(--color-text-secondary);
      font-weight: bold;
    }
    
    /* Style for user info */
    .balance-display {
      background-color: var(--color-bg-secondary);
      padding: 8px 12px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .balance-value {
      font-weight: bold;
      color: var(--color-success);
    }
    
    /* Responsive layouts */
    @media (min-width: 768px) {
      .game-content {
        grid-template-areas: 'betting playground';
        grid-template-columns: 300px 1fr;
      }
    }
    
    @media (max-width: 767px) {
      .game-content {
        grid-template-areas: 'playground' 'betting';
        grid-template-columns: 1fr;
      }
      
      .header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }
      
      .header-right {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="outer-container">
    <div id="game-container" class="game-container pc">
      <header class="header">
        <div class="header-left">
          <h1 class="portal-title game-title">Playtagon</h1>
        </div>
        <div class="header-right">
          <!-- Balance display -->
          <div class="balance-display">
            <span class="wallet-label">Wallet</span>
            <div class="balance-value-container">
              <span class="balance-value" id="balance-display">1000.00</span>
            </div>
          </div>
        </div>
      </header>
      
      <div class="game-content">
        <!-- Betting Zone -->
        <div class="betting-zone" style="grid-area: betting;">
          <!-- Bet Amount Panel -->
          <div class="control-panel">
            <div class="control-panel-header">
              <span class="control-panel-title">Bet Amount</span>
            </div>
            <div class="bet-input-group">
              <button class="btn btn-outline" id="decrease-bet">-</button>
              <input type="text" class="bet-input" id="bet-input" value="10" readonly>
              <button class="btn btn-outline" id="increase-bet">+</button>
            </div>
            <div class="quick-bets">
              <button class="quick-bet" id="half-bet">1/2</button>
              <button class="quick-bet" id="double-bet">×2</button>
              <button class="quick-bet" id="max-bet">Max</button>
            </div>
          </div>
          
          <!-- Risk Level Panel -->
          <div class="risk-panel">
            <span class="risk-panel-title">Risk Level</span>
            <div class="select-wrapper">
              <select id="risk-level" class="select-dropdown">
                <option value="low">Low Risk</option>
                <option value="medium" selected>Medium Risk</option>
                <option value="high">High Risk</option>
              </select>
            </div>
          </div>
          
          <!-- Game Selection -->
          <div class="risk-panel">
            <span class="risk-panel-title">Select Game</span>
            <div class="select-wrapper">
              <select id="game-select" class="select-dropdown">
                <option value="dice" selected>Dice Game</option>
                <option value="card">Card Game</option>
              </select>
            </div>
          </div>
          
          <!-- Play Controls -->
          <div class="play-controls">
            <button class="spin-btn" id="spin-button">SPIN</button>
          </div>
        </div>
        
        <!-- Playground Zone -->
        <div class="playground-zone" style="grid-area: playground;">
          <canvas id="game-canvas"></canvas>
          <div id="status-message" style="position: absolute; bottom: 10px; left: 10px; color: #2ea043; font-size: 14px;"></div>
        </div>
      </div>
      
      <footer class="footer">
        <div>Game Framework</div>
        <div id="current-time">00:00:00</div>
        <div id="footer-game-title">Dice Game</div>
      </footer>
    </div>
  </div>
  
  <!-- All JavaScript is inline to avoid loading issues -->
  <script>
    // Game Framework - All-in-one implementation
    (function() {
      // ============= STATE MANAGEMENT =============
      // Game state
      const state = {
        balance: 1000,
        bet: 10,
        minBet: 5,
        maxBet: 500,
        riskLevel: 'medium',
        riskMultipliers: {
          low: 1.5,
          medium: 3,
          high: 6
        },
        activeGameId: 'dice',
        diceValue: 1,
        isRolling: false,
        cards: [],
        isDealing: false,
        currentCardIndex: 0,
        dealingComplete: false
      };
      
      // ============= UI ELEMENTS =============
      const elements = {
        canvas: document.getElementById('game-canvas'),
        statusMessage: document.getElementById('status-message'),
        balanceDisplay: document.getElementById('balance-display'),
        betInput: document.getElementById('bet-input'),
        decreaseBet: document.getElementById('decrease-bet'),
        increaseBet: document.getElementById('increase-bet'),
        halfBet: document.getElementById('half-bet'),
        doubleBet: document.getElementById('double-bet'),
        maxBet: document.getElementById('max-bet'),
        gameSelect: document.getElementById('game-select'),
        riskLevel: document.getElementById('risk-level'),
        spinButton: document.getElementById('spin-button'),
        currentTime: document.getElementById('current-time'),
        footerGameTitle: document.getElementById('footer-game-title')
      };
      
      // ============= CANVAS MANAGER =============
      const canvasManager = {
        canvas: null,
        ctx: null,
        
        // Initialize canvas
        init: function(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d');
          this.resize();
          window.addEventListener('resize', () => this.resize());
          return true;
        },
        
        // Resize canvas to match display size
        resize: function() {
          if (!this.canvas) return;
          
          const displayWidth = this.canvas.clientWidth;
          const displayHeight = this.canvas.clientHeight;
          
          if (this.canvas.width !== displayWidth || this.canvas.height !== displayHeight) {
            this.canvas.width = displayWidth;
            this.canvas.height = displayHeight;
          }
        },
        
        // Clear canvas
        clear: function() {
          if (!this.ctx || !this.canvas) return;
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        },
        
        // Draw background
        drawBackground: function() {
          if (!this.ctx || !this.canvas) return;
          
          // Create gradient
          const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
          gradient.addColorStop(0, '#0d1117');
          gradient.addColorStop(1, '#161b22');
          
          // Fill background
          this.ctx.fillStyle = gradient;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          
          // Draw grid
          this.drawGrid();
        },
        
        // Draw grid
        drawGrid: function() {
          if (!this.ctx || !this.canvas) return;
          
          this.ctx.strokeStyle = 'rgba(88, 166, 255, 0.1)';
          this.ctx.lineWidth = 1;
          
          const gridSize = 30;
          
          // Draw vertical lines
          for (let x = 0; x <= this.canvas.width; x += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.canvas.height);
            this.ctx.stroke();
          }
          
          // Draw horizontal lines
          for (let y = 0; y <= this.canvas.height; y += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
          }
        },
        
        // Draw text
        drawText: function(text, x, y, options = {}) {
          if (!this.ctx) return;
          
          const {
            font = 'Arial',
            size = 16,
            weight = 'normal',
            color = '#ffffff',
            align = 'center',
            baseline = 'middle'
          } = options;
          
          this.ctx.font = `${weight} ${size}px ${font}`;
          this.ctx.fillStyle = color;
          this.ctx.textAlign = align;
          this.ctx.textBaseline = baseline;
          this.ctx.fillText(text, x, y);
        },
        
        // Draw rectangle
        drawRect: function(x, y, width, height, fillColor, strokeColor, strokeWidth = 1) {
          if (!this.ctx) return;
          
          this.ctx.beginPath();
          this.ctx.rect(x, y, width, height);
          
          if (fillColor) {
            this.ctx.fillStyle = fillColor;
            this.ctx.fill();
          }
          
          if (strokeColor) {
            this.ctx.strokeStyle = strokeColor;
            this.ctx.lineWidth = strokeWidth;
            this.ctx.stroke();
          }
        },
        
        // Draw circle
        drawCircle: function(x, y, radius, fillColor, strokeColor, strokeWidth = 1) {
          if (!this.ctx) return;
          
          this.ctx.beginPath();
          this.ctx.arc(x, y, radius, 0, Math.PI * 2);
          
          if (fillColor) {
            this.ctx.fillStyle = fillColor;
            this.ctx.fill();
          }
          
          if (strokeColor) {
            this.ctx.strokeStyle = strokeColor;
            this.ctx.lineWidth = strokeWidth;
            this.ctx.stroke();
          }
        }
      };
      
      // ============= GAME MANAGER =============
      const gameManager = {
        // Initialize game manager
        init: function() {
          console.log('Game Manager: Initializing');
          
          // Initialize canvas
          const canvasInitialized = canvasManager.init(elements.canvas);
          if (!canvasInitialized) {
            this.showStatus('Failed to initialize canvas', true);
            return false;
          }
          
          // Set up event listeners
          this.setupEventListeners();
          
          // Update displays
          this.updateBalanceDisplay();
          this.updateBetDisplay();
          this.updatePotentialWinDisplay();
          this.updateTimeDisplay();
          
          // Start time updater
          this.startTimeUpdater();
          
          // Show initial status
          this.showStatus('Game framework ready!');
          
          // Load initial game
          this.loadGame('dice');
          
          return true;
        },
        
        // Set up event listeners
        setupEventListeners: function() {
          // Spin button
          if (elements.spinButton) {
            elements.spinButton.addEventListener('click', () => this.handleSpin());
          }
          
          // Game select
          if (elements.gameSelect) {
            elements.gameSelect.addEventListener('change', (e) => {
              this.loadGame(e.target.value);
            });
          }
          
          // Betting controls
          if (elements.decreaseBet) {
            elements.decreaseBet.addEventListener('click', () => this.changeBet(-5));
          }
          
          if (elements.increaseBet) {
            elements.increaseBet.addEventListener('click', () => this.changeBet(5));
          }
          
          if (elements.halfBet) {
            elements.halfBet.addEventListener('click', () => this.setBetFraction(0.5));
          }
          
          if (elements.doubleBet) {
            elements.doubleBet.addEventListener('click', () => this.setBetFraction(2));
          }
          
          if (elements.maxBet) {
            elements.maxBet.addEventListener('click', () => this.setBet(state.maxBet));
          }
          
          // Risk level
          if (elements.riskLevel) {
            elements.riskLevel.addEventListener('change', (e) => {
              state.riskLevel = e.target.value;
              this.updatePotentialWinDisplay();
            });
          }
        },
        
        // Load a game
        loadGame: function(gameId) {
          console.log(`Game Manager: Loading game '${gameId}'`);
          
          // Update active game
          state.activeGameId = gameId;
          
          // Update title
          const gameName = gameId === 'dice' ? 'Dice Game' : 'Card Game';
          this.updateGameTitle(gameName);
          
          // Reset game state
          state.isRolling = false;
          state.isDealing = false;
          state.dealingComplete = false;
          state.diceValue = 1;
          state.cards = [];
          
          // Draw the game
          this.drawGame();
          
          // Show status
          this.showStatus(`Loaded ${gameName}`);
          
          return true;
        },
        
        // Handle spin button click
        handleSpin: function() {
          if (state.activeGameId === 'dice') {
            this.rollDice();
          } else if (state.activeGameId === 'card') {
            this.dealCards();
          }
        },
        
        // Roll dice
        rollDice: function() {
          if (state.isRolling) return;
          
          // Check balance
          if (state.balance < state.bet) {
            this.showStatus('Not enough balance to play!', true);
            return;
          }
          
          // Deduct bet
          this.updateBalance(-state.bet, 'dice bet');
          
          // Start rolling animation
          state.isRolling = true;
          let rollCount = 0;
          
          const rollInterval = setInterval(() => {
            state.diceValue = Math.floor(Math.random() * 6) + 1;
            this.drawGame();
            
            rollCount++;
            if (rollCount >= 10) {
              clearInterval(rollInterval);
              state.isRolling = false;
              this.handleDiceResult();
            }
          }, 100);
        },
        
        // Handle dice result
        handleDiceResult: function() {
          const diceValue = state.diceValue;
          
          // Check for win (4, 5, or 6 wins)
          if (diceValue >= 4) {
            // Calculate win amount based on dice value
            const multiplier = diceValue === 4 ? 2 : diceValue === 5 ? 3 : 5;
            const winAmount = state.bet * multiplier;
            
            // Update balance
            this.updateBalance(winAmount, `dice win (rolled ${diceValue})`);
            
            // Show message
            this.showStatus(`You rolled ${diceValue} and won ${winAmount}!`);
          } else {
            // Show message for loss
            this.showStatus(`You rolled ${diceValue} and lost your bet.`, true);
          }
          
          // Redraw with final result
          this.drawGame();
        },
        
        // Deal cards
        dealCards: function() {
          if (state.isDealing) return;
          
          // Check balance
          if (state.balance < state.bet) {
            this.showStatus('Not enough balance to play!', true);
            return;
          }
          
          // Deduct bet
          this.updateBalance(-state.bet, 'card bet');
          
          // Reset card state
          state.isDealing = true;
          state.dealingComplete = false;
          state.currentCardIndex = 0;
          state.cards = [];
          
          // Define card suits and values
          const suits = ['♥', '♦', '♠', '♣'];
          const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
          
          // Create deck
          const deck = [];
          for (const suit of suits) {
            for (const value of values) {
              deck.push({ suit, value });
            }
          }
          
          // Shuffle deck
          for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
          }
          
          // Deal cards with animation
          const dealInterval = setInterval(() => {
            if (state.currentCardIndex < 5) {
              state.cards.push(deck.pop());
              state.currentCardIndex++;
              this.drawGame();
            } else {
              clearInterval(dealInterval);
              state.isDealing = false;
              state.dealingComplete = true;
              this.handleCardResult();
            }
          }, 300);
        },
        
        // Handle card result
        handleCardResult: function() {
          // Check for combinations
          const valueCounts = {};
          for (const card of state.cards) {
            valueCounts[card.value] = (valueCounts[card.value] || 0) + 1;
          }
          
          // Get highest counts
          let maxCount = 0;
          let pairs = 0;
          
          for (const value in valueCounts) {
            if (valueCounts[value] > maxCount) {
              maxCount = valueCounts[value];
            }
            if (valueCounts[value] === 2) {
              pairs++;
            }
          }
          
          // Determine win amount
          let winAmount = 0;
          let message = '';
          
          if (maxCount === 4) {
            winAmount = state.bet * 100;
            message = `Four of a Kind! You won ${winAmount}!`;
          } else if (maxCount === 3 && pairs === 1) {
            winAmount = state.bet * 50;
            message = `Full House! You won ${winAmount}!`;
          } else if (maxCount === 3) {
            winAmount = state.bet * 30;
            message = `Three of a Kind! You won ${winAmount}!`;
          } else if (pairs === 2) {
            winAmount = state.bet * 20;
            message = `Two Pair! You won ${winAmount}!`;
          } else if (pairs === 1) {
            winAmount = state.bet * 10;
            message = `One Pair! You won ${winAmount}!`;
          } else {
            message = 'No winning combination. Try again!';
          }
          
          // Update balance if win
          if (winAmount > 0) {
            this.updateBalance(winAmount, `card win (${message})`);
          }
          
          // Show message
          this.showStatus(message, winAmount === 0);
          
          // Redraw with final result
          this.drawGame();
        },
        
        // Draw the current game
        drawGame: function() {
          // Clear and draw background
          canvasManager.clear();
          canvasManager.drawBackground();
          
          // Draw based on active game
          if (state.activeGameId === 'dice') {
            this.drawDiceGame();
          } else if (state.activeGameId === 'card') {
            this.drawCardGame();
          }
        },
        
        // Draw dice game
        drawDiceGame: function() {
          const { canvas } = canvasManager;
          
          // Draw title
          canvasManager.drawText('Dice Game', canvas.width / 2, 30, {
            size: 24,
            weight: 'bold',
            color: '#58a6ff'
          });
          
          // Draw dice
          const size = Math.min(canvas.width, canvas.height) * 0.3;
          const x = (canvas.width - size) / 2;
          const y = (canvas.height - size) / 2;
          
          // Draw dice body
          canvasManager.drawRect(x, y, size, size, 'white', '#0d1117', 3);
          
          // Draw dots
          const dotSize = size * 0.15;
          const padding = size * 0.2;
          
          function drawDot(xPos, yPos) {
            canvasManager.drawCircle(x + xPos, y + yPos, dotSize / 2, '#0d1117');
          }
          
          // Draw dots based on dice value
          switch (state.diceValue) {
            case 1:
              drawDot(size / 2, size / 2);
              break;
            case 2:
              drawDot(padding, padding);
              drawDot(size - padding, size - padding);
              break;
            case 3:
              drawDot(padding, padding);
              drawDot(size / 2, size / 2);
              drawDot(size - padding, size - padding);
              break;
            case 4:
              drawDot(padding, padding);
              drawDot(padding, size - padding);
              drawDot(size - padding, padding);
              drawDot(size - padding, size - padding);
              break;
            case 5:
              drawDot(padding, padding);
              drawDot(padding, size - padding);
              drawDot(size / 2, size / 2);
              drawDot(size - padding, padding);
              drawDot(size - padding, size - padding);
              break;
            case 6:
              drawDot(padding, padding);
              drawDot(padding, size / 2);
              drawDot(padding, size - padding);
              drawDot(size - padding, padding);
              drawDot(size - padding, size / 2);
              drawDot(size - padding, size - padding);
              break;
          }
          
          // Draw instructions
          if (!state.isRolling) {
            canvasManager.drawText('Press SPIN to roll the dice', canvas.width / 2, canvas.height - 30, {
              size: 16,
              color: '#2ea043'
            });
            
            // Draw game rules
            canvasManager.drawText('Rules: Roll 4, 5, or 6 to win!', canvas.width / 2, 60, {
              size: 14,
              color: '#8b949e'
            });
            
            // Draw payout info
            canvasManager.drawText('Win: 4 = 2x, 5 = 3x, 6 = 5x bet', canvas.width / 2, 80, {
              size: 14,
              color: '#8b949e'
            });
          }
        },
        
        // Draw card game
        drawCardGame: function() {
          const { canvas } = canvasManager;
          
          // Draw title
          canvasManager.drawText('Card Game', canvas.width / 2, 30, {
            size: 24,
            weight: 'bold',
            color: '#58a6ff'
          });
          
          // Draw cards
          const cardWidth = 80;
          const cardHeight = 120;
          const cardSpacing = 20;
          const totalWidth = cardWidth * 5 + cardSpacing * 4;
          const startX = (canvas.width - totalWidth) / 2;
          const y = (canvas.height - cardHeight) / 2;
          
          for (let i = 0; i < 5; i++) {
            const x = startX + i * (cardWidth + cardSpacing);
            
            if (i < state.cards.length) {
              // Draw card front
              const card = state.cards[i];
              
              // Draw card background
              canvasManager.drawRect(x, y, cardWidth, cardHeight, 'white', '#0d1117', 2);
              
              // Determine card color (red for hearts/diamonds, black for clubs/spades)
              const color = (card.suit === '♥' || card.suit === '♦') ? '#e63946' : '#0d1117';
              
              // Draw value
              canvasManager.drawText(card.value, x + 15, y + 25, {
                size: 24,
                weight: 'bold',
                color,
                align: 'left',
                baseline: 'middle'
              });
              
              // Draw suit
              canvasManager.drawText(card.suit, x + 15, y + 70, {
                size: 36,
                color,
                align: 'left',
                baseline: 'middle'
              });
              
              // Draw small corner value and suit
              canvasManager.drawText(card.value, x + cardWidth - 15, y + cardHeight - 15, {
                size: 14,
                weight: 'bold',
                color,
                align: 'right',
                baseline: 'middle'
              });
              
              canvasManager.drawText(card.suit, x + cardWidth - 15, y + cardHeight - 35, {
                size: 14,
                color,
                align: 'right',
                baseline: 'middle'
              });
            } else {
              // Draw card back
              canvasManager.drawRect(x, y, cardWidth, cardHeight, '#58a6ff', '#0d1117', 2);
              
              // Draw pattern
              for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 3; col++) {
                  canvasManager.drawRect(x + 15 + col * 20, y + 15 + row * 20, 10, 10, '#0d1117');
                }
              }
            }
          }
          
          // Draw instructions or results
          if (!state.isDealing && state.cards.length === 0) {
            canvasManager.drawText('Press SPIN to deal cards', canvas.width / 2, canvas.height - 30, {
              size: 16,
              color: '#2ea043'
            });
            
            // Draw game rules
            canvasManager.drawText('Rules: Make poker combinations to win!', canvas.width / 2, 60, {
              size: 14,
              color: '#8b949e'
            });
            
            // Draw payout info
            canvasManager.drawText('Payouts: 4-Kind: 100x, Full House: 50x, 3-Kind: 30x', canvas.width / 2, 80, {
              size: 14,
              color: '#8b949e'
            });
            
            canvasManager.drawText('Two Pair: 20x, Pair: 10x', canvas.width / 2, 100, {
              size: 14,
              color: '#8b949e'
            });
          } else if (state.dealingComplete) {
            // Identify hand type
            const valueCounts = {};
            for (const card of state.cards) {
              valueCounts[card.value] = (valueCounts[card.value] || 0) + 1;
            }
            
            let maxCount = 0;
            let pairs = 0;
            
            for (const value in valueCounts) {
              if (valueCounts[value] > maxCount) {
                maxCount = valueCounts[value];
              }
              if (valueCounts[value] === 2) {
                pairs++;
              }
            }
            
            let resultText = 'No winning combination';
            
            if (maxCount === 4) {
              resultText = 'Four of a Kind!';
            } else if (maxCount === 3 && pairs === 1) {
              resultText = 'Full House!';
            } else if (maxCount === 3) {
              resultText = 'Three of a Kind!';
            } else if (pairs === 2) {
              resultText = 'Two Pair!';
            } else if (pairs === 1) {
              resultText = 'One Pair!';
            }
            
            canvasManager.drawText(resultText, canvas.width / 2, canvas.height - 30, {
              size: 18,
              weight: 'bold',
              color: resultText === 'No winning combination' ? '#f85149' : '#2ea043'
            });
          }
        },
        
        // Change bet amount
        changeBet: function(amount) {
          const newBet = Math.max(state.minBet, Math.min(state.maxBet, state.bet + amount));
          this.setBet(newBet);
        },
        
        // Set bet to a fraction of current bet
        setBetFraction: function(fraction) {
          const newBet = Math.max(state.minBet, Math.min(state.maxBet, Math.floor(state.bet * fraction)));
          this.setBet(newBet);
        },
        
        // Set bet amount directly
        setBet: function(amount) {
          state.bet = Math.max(state.minBet, Math.min(state.maxBet, amount));
          this.updateBetDisplay();
          this.updatePotentialWinDisplay();
        },
        
        // Update the bet display
        updateBetDisplay: function() {
          if (elements.betInput) {
            elements.betInput.value = state.bet;
          }
        },
        
        // Update balance
        updateBalance: function(amount, reason = '') {
          // Update balance
          state.balance += amount;
          
          // Update display
          this.updateBalanceDisplay();
          
          // Return new balance
          return state.balance;
        },
        
        // Update the balance display
        updateBalanceDisplay: function() {
          if (elements.balanceDisplay) {
            elements.balanceDisplay.textContent = state.balance;
          }
        },
        
        // Update potential win display
        updatePotentialWinDisplay: function() {
          const multiplier = state.riskMultipliers[state.riskLevel] || 3;
          const potentialWin = state.bet * multiplier;
          // This would normally update a UI element, but we don't have one in this simplified version
        },
        
        // Start time updater
        startTimeUpdater: function() {
          // Update immediately
          this.updateTimeDisplay();
          
          // Update every second
          setInterval(() => this.updateTimeDisplay(), 1000);
        },
        
        // Update time display
        updateTimeDisplay: function() {
          if (elements.currentTime) {
            const now = new Date();
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const seconds = now.getSeconds().toString().padStart(2, '0');
            elements.currentTime.textContent = `${hours}:${minutes}:${seconds}`;
          }
        },
        
        // Update game title
        updateGameTitle: function(title) {
          document.title = title;
          
          if (elements.footerGameTitle) {
            elements.footerGameTitle.textContent = title;
          }
        },
        
        // Show status message
        showStatus: function(message, isError = false) {
          console.log(message);
          
          if (elements.statusMessage) {
            elements.statusMessage.textContent = message;
            elements.statusMessage.style.color = isError ? '#f85149' : '#2ea043';
          }
        }
      };
      
      // ============= INITIALIZATION =============
      // Initialize on DOM content loaded
      document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM Content Loaded - Initializing game framework');
        gameManager.init();
      });
      
      // Initialize immediately if DOM is already loaded
      if (document.readyState !== 'loading') {
        console.log('DOM already loaded - Initializing game framework immediately');
        gameManager.init();
      }
    })();
  </script>
</body>
</html>