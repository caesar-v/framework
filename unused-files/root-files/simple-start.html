<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple Game Framework</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #0d1117;
      color: #c9d1d9;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    
    h1 {
      color: #58a6ff;
      text-align: center;
    }
    
    .game-container {
      background-color: #161b22;
      border-radius: 8px;
      padding: 20px;
      margin-top: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    canvas {
      width: 100%;
      height: 400px;
      background-color: #0d1117;
      border-radius: 4px;
      display: block;
    }
    
    .controls {
      margin-top: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .control-group {
      display: flex;
      gap: 10px;
    }
    
    button {
      background-color: #238636;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      cursor: pointer;
      font-weight: bold;
    }
    
    button:hover {
      background-color: #2ea043;
    }
    
    .info {
      margin-top: 20px;
      background-color: #161b22;
      border-radius: 8px;
      padding: 15px;
    }
    
    #status-message {
      background-color: #0d1117;
      border-radius: 4px;
      padding: 10px;
      margin-top: 10px;
      min-height: 20px;
    }
    
    .balance {
      font-size: 18px;
      font-weight: bold;
      color: #58a6ff;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Simple Game Framework</h1>
    
    <div class="game-container">
      <canvas id="game-canvas"></canvas>
      
      <div class="controls">
        <div class="control-group">
          <button id="spin-button">SPIN</button>
          <select id="game-select">
            <option value="dice">Dice Game</option>
            <option value="card">Card Game</option>
          </select>
        </div>
        
        <div class="balance">Balance: <span id="balance-display">1000</span></div>
      </div>
      
      <div id="status-message"></div>
    </div>
    
    <div class="info">
      <p>This is a simplified version of the game framework. The original framework modules have been preserved but are not loaded in this simplified version.</p>
    </div>
  </div>

  <!-- Core Scripts - Keep it extremely simple -->
  <script>
    // Simple status message function
    function showStatus(message, isError = false) {
      const statusEl = document.getElementById('status-message');
      if (statusEl) {
        statusEl.textContent = message;
        statusEl.style.color = isError ? '#f85149' : '#2ea043';
      }
      console.log(message);
    }
    
    // Initialize the game canvas
    function initCanvas() {
      const canvas = document.getElementById('game-canvas');
      if (!canvas) return null;
      
      const ctx = canvas.getContext('2d');
      
      // Size the canvas properly (responsive design)
      function resizeCanvas() {
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        
        // Only resize if necessary to avoid clearing canvas
        if (canvas.width !== width || canvas.height !== height) {
          canvas.width = width;
          canvas.height = height;
        }
      }
      
      // Listen for resize events
      window.addEventListener('resize', resizeCanvas);
      
      // Initial resize
      resizeCanvas();
      
      // Draw a background
      function drawBackground() {
        if (!ctx) return;
        
        // Create gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#0d1117');
        gradient.addColorStop(1, '#161b22');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Add a grid pattern
        ctx.strokeStyle = 'rgba(88, 166, 255, 0.1)';
        ctx.lineWidth = 1;
        
        const gridSize = 30;
        
        for (let x = 0; x <= canvas.width; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        
        for (let y = 0; y <= canvas.height; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
      }
      
      // Initial draw
      drawBackground();
      
      return {
        canvas,
        ctx,
        drawBackground,
        resizeCanvas
      };
    }
    
    // Simple dice game
    function createDiceGame(canvasManager) {
      const { canvas, ctx } = canvasManager;
      let diceValue = 1;
      let isRolling = false;
      let balance = 1000;
      
      // Update balance display
      function updateBalance() {
        const balanceEl = document.getElementById('balance-display');
        if (balanceEl) balanceEl.textContent = balance;
      }
      
      // Roll the dice
      function rollDice() {
        if (isRolling) return;
        
        isRolling = true;
        showStatus('Rolling dice...');
        
        // Check if we have enough balance
        if (balance < 10) {
          showStatus('Not enough balance to play!', true);
          isRolling = false;
          return;
        }
        
        // Deduct bet
        balance -= 10;
        updateBalance();
        
        // Simulate dice rolling animation
        let rollCount = 0;
        const maxRolls = 20;
        const rollInterval = setInterval(() => {
          diceValue = Math.floor(Math.random() * 6) + 1;
          draw();
          rollCount++;
          
          if (rollCount >= maxRolls) {
            clearInterval(rollInterval);
            isRolling = false;
            handleResult(diceValue);
          }
        }, 50);
      }
      
      // Handle the roll result
      function handleResult(value) {
        if (value > 3) {
          // Win
          const winAmount = value * 5;
          balance += winAmount;
          showStatus(`You rolled ${value} and won ${winAmount}!`);
        } else {
          // Lose
          showStatus(`You rolled ${value} and lost your bet.`);
        }
        updateBalance();
      }
      
      // Draw the dice
      function draw() {
        if (!ctx) return;
        
        // Clear canvas with background
        canvasManager.drawBackground();
        
        // Draw dice
        const size = Math.min(canvas.width, canvas.height) * 0.3;
        const x = (canvas.width - size) / 2;
        const y = (canvas.height - size) / 2;
        
        // Draw dice body
        ctx.fillStyle = 'white';
        ctx.strokeStyle = '#0d1117';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.roundRect(x, y, size, size, 15);
        ctx.fill();
        ctx.stroke();
        
        // Draw dots
        const dotSize = size * 0.15;
        const padding = size * 0.2;
        ctx.fillStyle = '#0d1117';
        
        function drawDot(xPos, yPos) {
          ctx.beginPath();
          ctx.arc(x + xPos, y + yPos, dotSize / 2, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw dots based on dice value
        switch (diceValue) {
          case 1:
            drawDot(size / 2, size / 2);
            break;
          case 2:
            drawDot(padding, padding);
            drawDot(size - padding, size - padding);
            break;
          case 3:
            drawDot(padding, padding);
            drawDot(size / 2, size / 2);
            drawDot(size - padding, size - padding);
            break;
          case 4:
            drawDot(padding, padding);
            drawDot(padding, size - padding);
            drawDot(size - padding, padding);
            drawDot(size - padding, size - padding);
            break;
          case 5:
            drawDot(padding, padding);
            drawDot(padding, size - padding);
            drawDot(size / 2, size / 2);
            drawDot(size - padding, padding);
            drawDot(size - padding, size - padding);
            break;
          case 6:
            drawDot(padding, padding);
            drawDot(padding, size / 2);
            drawDot(padding, size - padding);
            drawDot(size - padding, padding);
            drawDot(size - padding, size / 2);
            drawDot(size - padding, size - padding);
            break;
        }
        
        // Add text
        ctx.fillStyle = '#58a6ff';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Dice Game', canvas.width / 2, 30);
        
        if (!isRolling) {
          ctx.fillStyle = '#2ea043';
          ctx.font = '16px Arial';
          ctx.fillText('Press SPIN to roll the dice', canvas.width / 2, canvas.height - 20);
        }
      }
      
      // Initial draw
      draw();
      
      return {
        name: 'Dice Game',
        id: 'dice',
        rollDice,
        draw,
        updateBalance,
        getBalance: () => balance,
        setBalance: (newBalance) => {
          balance = newBalance;
          updateBalance();
        }
      };
    }
    
    // Simple card game
    function createCardGame(canvasManager) {
      const { canvas, ctx } = canvasManager;
      let cards = [];
      let isDealing = false;
      let balance = 1000;
      
      // Card suits and values
      const suits = ['♥', '♦', '♠', '♣'];
      const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
      
      // Update balance display
      function updateBalance() {
        const balanceEl = document.getElementById('balance-display');
        if (balanceEl) balanceEl.textContent = balance;
      }
      
      // Deal cards
      function dealCards() {
        if (isDealing) return;
        
        isDealing = true;
        showStatus('Dealing cards...');
        
        // Check if we have enough balance
        if (balance < 10) {
          showStatus('Not enough balance to play!', true);
          isDealing = false;
          return;
        }
        
        // Deduct bet
        balance -= 10;
        updateBalance();
        
        // Create new deck
        const deck = [];
        for (const suit of suits) {
          for (const value of values) {
            deck.push({ suit, value });
          }
        }
        
        // Shuffle deck
        for (let i = deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        
        // Deal 5 cards
        cards = [];
        
        const dealInterval = setInterval(() => {
          if (cards.length < 5) {
            cards.push(deck.pop());
            draw();
          } else {
            clearInterval(dealInterval);
            isDealing = false;
            handleResult();
          }
        }, 300);
      }
      
      // Handle the result
      function handleResult() {
        // Check for pairs
        const valueCounts = {};
        for (const card of cards) {
          valueCounts[card.value] = (valueCounts[card.value] || 0) + 1;
        }
        
        // Get the highest pair or three of a kind
        let maxCount = 0;
        let pairs = 0;
        
        for (const value in valueCounts) {
          if (valueCounts[value] > maxCount) {
            maxCount = valueCounts[value];
          }
          if (valueCounts[value] === 2) {
            pairs++;
          }
        }
        
        // Calculate winnings
        let winAmount = 0;
        let message = '';
        
        if (maxCount === 4) {
          winAmount = 100;
          message = 'Four of a Kind! You won 100!';
        } else if (maxCount === 3 && pairs === 1) {
          winAmount = 50;
          message = 'Full House! You won 50!';
        } else if (maxCount === 3) {
          winAmount = 30;
          message = 'Three of a Kind! You won 30!';
        } else if (pairs === 2) {
          winAmount = 20;
          message = 'Two Pair! You won 20!';
        } else if (pairs === 1) {
          winAmount = 10;
          message = 'One Pair! You won 10!';
        } else {
          message = 'No winning combination. Try again!';
        }
        
        balance += winAmount;
        showStatus(message, winAmount === 0);
        updateBalance();
      }
      
      // Draw the cards
      function draw() {
        if (!ctx) return;
        
        // Clear canvas with background
        canvasManager.drawBackground();
        
        // Add text
        ctx.fillStyle = '#58a6ff';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Card Game', canvas.width / 2, 30);
        
        // Draw cards
        const cardWidth = 80;
        const cardHeight = 120;
        const startX = (canvas.width - (cardWidth * 5 + 20 * 4)) / 2;
        const y = (canvas.height - cardHeight) / 2;
        
        for (let i = 0; i < 5; i++) {
          const x = startX + i * (cardWidth + 20);
          
          // Draw card back or front
          if (i < cards.length) {
            // Draw card front
            const card = cards[i];
            
            // Draw card background
            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#0d1117';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(x, y, cardWidth, cardHeight, 10);
            ctx.fill();
            ctx.stroke();
            
            // Draw card value and suit
            const color = (card.suit === '♥' || card.suit === '♦') ? '#e63946' : '#0d1117';
            ctx.fillStyle = color;
            
            // Draw value
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(card.value, x + 10, y + 30);
            
            // Draw suit
            ctx.font = '36px Arial';
            ctx.fillText(card.suit, x + 10, y + 80);
            
            // Draw small corner value and suit
            ctx.font = 'bold 14px Arial';
            ctx.fillText(card.value, x + cardWidth - 20, y + cardHeight - 10);
            ctx.font = '14px Arial';
            ctx.fillText(card.suit, x + cardWidth - 15, y + cardHeight - 25);
          } else {
            // Draw card back
            ctx.fillStyle = '#58a6ff';
            ctx.strokeStyle = '#0d1117';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(x, y, cardWidth, cardHeight, 10);
            ctx.fill();
            ctx.stroke();
            
            // Draw pattern
            ctx.fillStyle = '#0d1117';
            for (let row = 0; row < 5; row++) {
              for (let col = 0; col < 3; col++) {
                ctx.beginPath();
                ctx.roundRect(
                  x + 15 + col * 20, 
                  y + 15 + row * 20, 
                  10, 10, 3
                );
                ctx.fill();
              }
            }
          }
        }
        
        if (!isDealing && cards.length === 0) {
          ctx.fillStyle = '#2ea043';
          ctx.font = '16px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('Press SPIN to deal cards', canvas.width / 2, canvas.height - 20);
        }
      }
      
      // Initial draw
      draw();
      
      return {
        name: 'Card Game',
        id: 'card',
        dealCards,
        draw,
        updateBalance,
        getBalance: () => balance,
        setBalance: (newBalance) => {
          balance = newBalance;
          updateBalance();
        }
      };
    }
    
    // Main app initialization
    function initApp() {
      showStatus('Initializing simple game framework...');
      
      // Initialize canvas
      const canvasManager = initCanvas();
      if (!canvasManager) {
        showStatus('Failed to initialize canvas', true);
        return;
      }
      
      // Create games
      const games = {
        dice: createDiceGame(canvasManager),
        card: createCardGame(canvasManager)
      };
      
      // Track active game
      let activeGameId = 'dice';
      
      // Set initial active game
      function setActiveGame(gameId) {
        if (!games[gameId]) {
          showStatus(`Game ${gameId} not found`, true);
          return;
        }
        
        // Save balance from current game
        const currentBalance = games[activeGameId].getBalance();
        
        // Update active game
        activeGameId = gameId;
        const newGame = games[activeGameId];
        
        // Transfer balance to new game
        newGame.setBalance(currentBalance);
        
        // Draw the new game
        newGame.draw();
        
        showStatus(`Switched to ${newGame.name}`);
      }
      
      // Set up event listeners
      const spinButton = document.getElementById('spin-button');
      if (spinButton) {
        spinButton.addEventListener('click', function() {
          const game = games[activeGameId];
          if (game) {
            if (game.id === 'dice') {
              game.rollDice();
            } else if (game.id === 'card') {
              game.dealCards();
            }
          }
        });
      }
      
      const gameSelect = document.getElementById('game-select');
      if (gameSelect) {
        gameSelect.addEventListener('change', function() {
          setActiveGame(this.value);
        });
      }
      
      // Initialize with default game
      setActiveGame(activeGameId);
      showStatus('Game framework ready!');
    }
    
    // Start the app when the DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      initApp();
    }
  </script>
</body>
</html>